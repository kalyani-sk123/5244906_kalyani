**SALES BY MATCH
CODE:

#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    int socks[n];
    
    for (int i = 0; i < n; i++) {
        scanf("%d", &socks[i]);
    }
    int colorCount[101] = {0}; 
    for (int i = 0; i < n; i++) {
        colorCount[socks[i]]++;
    }
    int pairs = 0;
    for (int i = 1; i <= 100; i++) {
        pairs += colorCount[i] / 2;
    }
    printf("%d\n", pairs);
    return 0;
}
---------------------------------------------------------------------------------
**DRAWING BOOK
CODE:

#include <stdio.h>
int main() {
    int n, p;
    scanf("%d %d", &n, &p);

    int frontTurns = p / 2;
    int backTurns = (n / 2) - frontTurns;

    int result = frontTurns < backTurns ? frontTurns : backTurns;

    printf("%d\n", result);

    return 0;
}
--------------------------------------------------------------------------
**TOWER BREAKERS
CODE:

#include<stdio.h>
int towerBreakers(int n, int m) {
    if(m == 1) {
        return 2;
    }
    if(n % 2 == 0) {
        return 2;
    }
    return 1;
}
int main() {
    int t;
    scanf("%d", &t);
    for(int i = 0;i< t;i++) {
        int n, m;
        scanf("%d %d", &n,&m);
        printf("%d\n", towerBreakers(n,m));
    }
    return 0;
}
-------------------------------------------------------------------------------
**CEASAR CIPHER
CODE:

#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main() {
    int n, k;
    scanf("%d", &n);            
    char s[n + 1];
    scanf("%s", s);            
    scanf("%d", &k);            

    k = k % 26; 
    for (int i = 0; i < n; i++) {
        char c = s[i];
        if (isupper(c)) {
            s[i] = ((c - 'A' + k) % 26) + 'A';
        } else if (islower(c)) {
            s[i] = ((c - 'a' + k) % 26) + 'a';
        }
    }

    printf("%s\n", s);
    return 0;
}
------------------------------------------------------------------------------------
**MAX MIN
CODE:

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int n, k;
    scanf("%d", &n);
    scanf("%d", &k);

    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    qsort(arr, n, sizeof(int), compare);
    int min_unfairness = INT_MAX;
    for (int i = 0; i <= n - k; i++) {
        int unfairness = arr[i + k - 1] - arr[i];
        if (unfairness < min_unfairness) {
            min_unfairness = unfairness;
        }
    }

    printf("%d\n", min_unfairness);

    return 0;
}
-------------------------------------------------------------------------------------
**DYNAMIC ARRAY
CODE:

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;
    int size;
    int capacity;
} Sequence;

void append(Sequence *seq, int value) {
    if (seq->size == seq->capacity) {
        seq->capacity = seq->capacity == 0 ? 1 : seq->capacity * 2;
        seq->data = realloc(seq->data, seq->capacity * sizeof(int));
    }
    seq->data[seq->size++] = value;
}

int main() {
    int n, q;
    scanf("%d %d", &n, &q);

    Sequence *arr = malloc(n * sizeof(Sequence));
    for (int i = 0; i < n; i++) {
        arr[i].data = NULL;
        arr[i].size = 0;
        arr[i].capacity = 0;
    }

    int lastAnswer = 0;
    int *answers = malloc(q * sizeof(int));
    int ansCount = 0;

    for (int i = 0; i < q; i++) {
        int type, x, y;
        scanf("%d %d %d", &type, &x, &y);
        int idx = (x ^ lastAnswer) % n;

        if (type == 1) {
            append(&arr[idx], y);
        } else if (type == 2) {
            lastAnswer = arr[idx].data[y % arr[idx].size];
            answers[ansCount++] = lastAnswer;
        }
    }

    for (int i = 0; i < ansCount; i++) {
        printf("%d\n", answers[i]);
    }

    for (int i = 0; i < n; i++) {
        free(arr[i].data);
    }
    free(arr);
    free(answers);

    return 0;
}
------------------------------------------------------------------------------------
**GRID CHALLANGE
CODE:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int cmpChar(const void *a, const void *b) {
    return (*(char*)a - *(char*)b);
}

const char* gridChallenge(int n, char grid[][n+1]) {
    for (int i = 0; i < n; i++) {
        qsort(grid[i], n, sizeof(char), cmpChar);
    }

    for (int col = 0; col < n; col++) {
        for (int row = 1; row < n; row++) {
            if (grid[row][col] < grid[row-1][col]) {
                return "NO";
            }
        }
    }
    return "YES";
}

int main() {
    int t;
    scanf("%d", &t);

    while (t--) {
        int n;
        scanf("%d", &n);

        char grid[n][n+1];

        for (int i = 0; i < n; i++) {
            scanf("%s", grid[i]);
        }

        printf("%s\n", gridChallenge(n, grid));
    }

    return 0;
}
----------------------------------------------------------------------------------
**SHERLOCK AND ARRAY
CODE:

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* readline();
char* ltrim(char*);
char* rtrim(char*);
char** split_string(char*);
int parse_int(char*);

char* balancedSums(int arr_count, int* arr) {
    long long totalSum = 0;
    long long leftSum = 0;
    for (int i = 0; i < arr_count; i++) {
        totalSum += arr[i];
    }
    for (int i = 0; i < arr_count; i++) {
        totalSum -= arr[i];
        if (leftSum == totalSum) {
            return "YES";
        }
        leftSum += arr[i];
    }
    return "NO";
}

int main()
{
    FILE* fptr = fopen(getenv("OUTPUT_PATH"), "w");
    int T = parse_int(ltrim(rtrim(readline())));
    for (int T_itr = 0; T_itr < T; T_itr++) {
        int n = parse_int(ltrim(rtrim(readline())));
        char** arr_temp = split_string(rtrim(readline()));
        int* arr = malloc(n * sizeof(int));
        for (int i = 0; i < n; i++) {
            int arr_item = parse_int(*(arr_temp + i));
            *(arr + i) = arr_item;
        }
        char* result = balancedSums(n, arr);
        fprintf(fptr, "%s\n", result);
        free(arr);
        free(arr_temp);
    }
    fclose(fptr);
    return 0;
}

char* readline() {
    size_t alloc_length = 1024;
    size_t data_length = 0;
    char* data = malloc(alloc_length);
    while (true) {
        char* cursor = data + data_length;
        char* line = fgets(cursor, alloc_length - data_length, stdin);
        if (!line) {
            break;
        }
        data_length += strlen(cursor);
        if (data_length < alloc_length - 1 || data[data_length - 1] == '\n') {
            break;
        }
        alloc_length <<= 1;
        data = realloc(data, alloc_length);
        if (!data) {
            data = '\0';
            break;
        }
    }
    if (data[data_length - 1] == '\n') {
        data[data_length - 1] = '\0';
        data = realloc(data, data_length);
        if (!data) {
            data = '\0';
        }
    } else {
        data = realloc(data, data_length + 1);
        if (!data) {
            data = '\0';
        } else {
            data[data_length] = '\0';
        }
    }
    return data;
}

char* ltrim(char* str) {
    if (!str) {
        return '\0';
    }
    if (!*str) {
        return str;
    }
    while (*str != '\0' && isspace(*str)) {
        str++;
    }
    return str;
}

char* rtrim(char* str) {
    if (!str) {
        return '\0';
    }
    if (!*str) {
        return str;
    }
    char* end = str + strlen(str) - 1;
    while (end >= str && isspace(*end)) {
        end--;
    }
    *(end + 1) = '\0';
    return str;
}

char** split_string(char* str) {
    char** splits = NULL;
    char* token = strtok(str, " ");
    int spaces = 0;
    while (token) {
        splits = realloc(splits, sizeof(char*) * ++spaces);
        if (!splits) {
            return splits;
        }
        splits[spaces - 1] = token;
        token = strtok(NULL, " ");
    }
    return splits;
}

int parse_int(char* str) {
    char* endptr;
    int value = strtol(str, &endptr, 10);
    if (endptr == str || *endptr != '\0') {
        exit(EXIT_FAILURE);
    }
    return value;
}
-------------------------------------------------------------------------------------
**RECURSIVE DIGIT SUM
CODE:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stddef.h>

char* readline() {
    size_t alloc_length = 1024;
    size_t data_length = 0;
    char* data = malloc(alloc_length);
    if (!data) return NULL;

    while (true) {
        char* cursor = data + data_length;
        if (fgets(cursor, alloc_length - data_length, stdin) == NULL) break;

        data_length += strlen(cursor);

        if (data_length < alloc_length - 1 || data[data_length - 1] == '\n') break;

        alloc_length <<= 1;
        char* temp = realloc(data, alloc_length);
        if (!temp) {
            free(data);
            return NULL;
        }
        data = temp;
    }

    if (data_length > 0 && data[data_length - 1] == '\n') {
        data[data_length - 1] = '\0';
        char* temp = realloc(data, data_length);
        if (temp) data = temp;
    } else {
        char* temp = realloc(data, data_length + 1);
        if (temp) {
            data = temp;
            data[data_length] = '\0';
        }
    }

    return data;
}

int superDigit(char* n, int k) {
    long long sum = 0;
    for (int i = 0; n[i] != '\0'; i++) {
        sum += (n[i] - '0');
    }
    sum *= k;

    while (sum > 9) {
        long long temp = 0;
        while (sum > 0) {
            temp += sum % 10;
            sum /= 10;
        }
        sum = temp;
    }

    return (int)sum;
}

int main() {
    char* input = readline();
    if (!input) return 1;

    char* token = strtok(input, " ");
    char* n = token;
    token = strtok(NULL, " ");
    int k = atoi(token);

    int result = superDigit(n, k);
    printf("%d\n", result);

    free(input);
    return 0;
}
---------------------------------------------------------------------------------------
**COUNTER GAME
CODE:

#include <stdio.h>
int isPowerOfTwo(unsigned long long n) {
    return (n && !(n & (n - 1)));
}
unsigned long long highestPowerOf2(unsigned long long n) {
    unsigned long long p = 1;
    while (p * 2 < n) {
        p *= 2;
    }
    return p;
}

int main() {
    int t;
    scanf("%d", &t);  
    while (t--) {
        unsigned long long n;
        scanf("%llu", &n);

        int count = 0; 

        while (n > 1) {
            if (isPowerOfTwo(n)) {
                n /= 2;
            } else {
                n -= highestPowerOf2(n);
            }
            count++;
        }

        if (count % 2 == 1) {
            printf("Louise\n");
        } else {
            printf("Richard\n");
        }
    }

    return 0;
}
---------------------------------------------------------------------------------
**SUM VS XOR
CODE:

#include <stdio.h>

long sumXor(long n) {
    if (n == 0) return 1;
    long zeros = 0;
    while (n) {
        if ((n & 1) == 0) zeros++;
        n >>= 1;
    }
    return 1L << zeros;
}

int main() {
    long n;
    scanf("%ld", &n);
    printf("%ld\n", sumXor(n));
    return 0;
}
---------------------------------------------------------------------------------